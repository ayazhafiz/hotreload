import * as cp from 'child_process';
import * as fs from 'fs';
import * as tempfile from 'tempy';

import {compileNative, CppCode, CppCodeGenerator, HotReloadFunction} from './compile';
import {die, error, info, warn} from './util';

const CPP_RUNTIME = 'runtime/runtime.cpp';
const CXX_FLAGS = '-std=c++17';

interface RegisteredHotReloadFunction extends
    Omit<HotReloadFunction, 'genTopLevelDefinition'|'impl'> {
  /**
   * The hot-reloadable function definition.
   * Unlike the compiler-generated definition, this one may be changed during
   * the runtime, so it is not readonly.
   */
  impl: CppCode;
  /**
   * File to write implementation in.
   * Generated by the compiler to be unique.
   */
  readonly srcFile: string;
  /**
   * File to write compiled output to.
   * Generated by the compiler to be unique.
   */
  readonly objFile: string;
  /**
   * File to write contents of `objFile` to and read from during the runtime of
   * the program.
   * This differs from `objFile` because we would like to ensure that even when
   * `objFile` is being re-compiled, the program can continue to function with
   * an old implementation from `objCopyFile`. Once `objFile` has been compiled
   * and the `lockfile` is removed, the `objCopyFile` should be updated.
   * Generated by the compiler to be unique.
   */
  readonly objCopyFile: string;
  /**
   * File added/deleted when `objFile` is being compiled, and should not be
   * read from.
   * Allocated by the compiler to be unique.
   */
  readonly lockFile: string;
}

/**
 * Allocates a unique temporary file and registers a handler to clean it up
 * when the runtime exits.
 */
function allocTempFile(ext?: string): string {
  // `tempfile.file` should be "unique-enough" to avoid collisions
  const file = tempfile.file({extension: ext});
  process.on('exit', () => {
    try {
      fs.unlinkSync(file)
    } catch (_e) {
    }
  });
  return file;
}

/** Pretty-prints to an output stream generated C++ code for a program. */
function printGenerated(
    hotReloads: RegisteredHotReloadFunction[], program: string,
    programFile: string) {
  let data = 'Generated C++ code:\n';
  for (const {srcFile, impl} of hotReloads) {
    data += `// ${srcFile}\n`;
    data += `${impl}\n\n`;
  }
  data += `// ${programFile}\n`;
  data += `/* <runtime snipped> */\n`;
  data += program;
  for (const line of data.split('\n')) {
    info(line);
  }
}

interface CompileResult {
  code: number;
  error?: string;
}

function compileCpp(
    impl: CppCode, srcFile: string, outFile: string,
    extraFlags = ''): CompileResult {
  const cxx = process.env['CXX'] || 'c++';
  fs.writeFileSync(srcFile, impl);
  try {
    cp.execSync(`${cxx} ${CXX_FLAGS}${extraFlags} -o ${outFile} ${srcFile}`, {
      stdio: ['ignore', 'pipe', 'pipe'],
    });
    return {code: 0};
  } catch (e) {
    return {code: e.status, error: e.message};
  }
}

function compileHotReload({impl, srcFile, objFile, lockFile}:
                              RegisteredHotReloadFunction): CompileResult {
  fs.writeFileSync(lockFile, 'locked');
  const result = compileCpp(impl, srcFile, objFile, ' -shared');
  fs.unlinkSync(lockFile);
  return result;
}

/**
 * Reconciles a list of known hot-reloadable functions associated with the
 * runtime with new definitions of hot-reloadable functions parsed out from a
 * changed program.
 */
function reconcileChangedHotReloadable(
    hotReloads: RegisteredHotReloadFunction[],
    newHotReloads: Map<string, HotReloadFunction>) {
  for (const hr of hotReloads) {
    const newHR = newHotReloads.get(hr.name);
    if (newHR === undefined) {
      warn(`Deletion of hot-reloadable "${
          hr.name}" during the runtime is unsupported.`);
      warn(`Continuing as if "${hr.name}" were not deleted.`);
      continue;
    }
    if (newHR.signature !== hr.signature) {
      warn(`Changing the type signature of "${
          hr.name}" during the runtime is unsupported.`);
      warn(`Continuing as if "${hr.name}" were not changed.`);
    }

    // All is good, we can replace the implementations as-needed and
    // recompile.
    if (hr.impl !== newHR.impl) {
      hr.impl = newHR.impl;
      const {code, error: compileError} = compileHotReload(hr);
      if (compileError !== undefined) {
        error(
            `Could not compile C++ code for ${hr.name} (exit code ${code}): `,
            compileError);
        error(`Program may be corrupted or terminate.`);
      }
      info(`"${hr.name}" has been reloaded.`);
    }

    // Delete the new hot reloaded function from the map so that we know
    // what is left over.
    newHotReloads.delete(hr.name);
  }

  if (newHotReloads.size > 0) {
    const fmtExtra =
        `${[...newHotReloads.keys()].map(k => `"${k}"`).join(', ')}`;
    warn(
        `Introduction of new hot-reloadable function(s) ` +
        `${fmtExtra} during the runtime is unsupported.`);
    warn(`Continuing as if these have not been introduced.`);
  }
}

export async function start(
    inputProgramFile: string,
    codegen: CppCodeGenerator,
    showGenerated: boolean,
    ): Promise<never> {
  // We are going to dealloc a lot of temporary resource when the runtime
  // terminates by way of .on('exit') listeners. This could be more efficient,
  // but let's just bump it up.
  process.setMaxListeners(128);

  // The TS program to perform rebuilds on top of.
  // This permits us to have relatively-fast rebuilds of the input program when
  // it changes, and we update the reference everytime a rebuild completes
  // successfully.
  let cachedTsProgram = codegen.tsProgram;

  const hotReloads: RegisteredHotReloadFunction[] = [];
  const hotReloadCodeDefs: CppCode[] = [];

  let taskNo = 0;
  const numTasks =
      // +1 = compile user program
      // +1 = start user program
      codegen.hotReload.length + 2;

  // First, we allocate new source, object, and lock files for each hot-reload
  // function, and compile each each function so that the program has something
  // fresh to work with.
  for (const hotReloadFunction of codegen.hotReload) {
    const name = hotReloadFunction.name;
    const srcFile = allocTempFile('.cpp');
    const objFile = allocTempFile();
    const objCopyFile = allocTempFile();
    const lockFile = allocTempFile();

    info(`[${++taskNo}/${numTasks}] Initializing .so for "${name}"...`);
    const hr: RegisteredHotReloadFunction =
        {...hotReloadFunction, srcFile, objFile, objCopyFile, lockFile};
    const {code, error} = compileHotReload(hr);
    if (error !== undefined) {
      die(`could not compile C++ code for "${name}" (exit code ${code}): `,
          error);
    }

    hotReloads.push(hr);
    hotReloadCodeDefs.push(hotReloadFunction.genTopLevelDefinition(
        objFile, objCopyFile, lockFile));
  };

  // Next, let's construct the actual C++ program file and compile it.
  const cppRuntime = fs.readFileSync(CPP_RUNTIME).toString() as CppCode;
  const cppProgramNoRt =
      [...hotReloadCodeDefs, ...codegen.topLevels, codegen.main].join('\n');
  const cppProgram = [cppRuntime, cppProgramNoRt].join('\n') as CppCode;
  const cppProgramFile = allocTempFile('.cpp');
  const binaryProgramFile = allocTempFile();

  if (showGenerated) {
    printGenerated(hotReloads, cppProgramNoRt, cppProgramFile);
  }

  info(`[${++taskNo}/${numTasks}] Compiling user program...`);
  const {code, error: compileError} =
      compileCpp(cppProgram, cppProgramFile, binaryProgramFile);
  if (compileError !== undefined) {
    die(`could not compile user program C++ code (exit code ${code}): `,
        compileError);
  }

  // Next, we need to listen for changes to the program file.
  fs.watch(inputProgramFile, {}, (event) => {
    switch (event) {
      case 'rename': {
        warn(
            'Rename or deletion of program file during the runtime is unsupported.');
        warn('Continuing as if file was not modified at all.');
        break;
      }
      case 'change': {
        // 1. parse the program file and extract its new C++ definitions
        const newHotReloads = new Map<string, HotReloadFunction>();
        try {
          const newProgram = compileNative(inputProgramFile, cachedTsProgram);
          for (const hr of newProgram.hotReload) {
            newHotReloads.set(hr.name, hr);
          }
          cachedTsProgram = newProgram.tsProgram;
        } catch (e) {
          error(e.message);
          warn(`Continuing as if the program has not changed.`);
          return;
        }
        // 2. reconcile changed functions
        reconcileChangedHotReloadable(hotReloads, newHotReloads);
        break;
      }
      default:
        error(`Unknown file change event "${event}"`);
    }
  });

  // Finally, we start the user program.
  info(`[${++taskNo}/${numTasks}] Starting user program...`);
  const main = cp.spawn(binaryProgramFile, {
    stdio: [process.stdin, process.stdout, process.stderr],
  });

  // The lifetime of the program is bounded by the lifetime of the runtime, and
  // vice versa. We do some trivial cleanup to make sure neither outlives the
  // other.
  let mainIsFinished = false;
  return new Promise<never>(() => {
    main.on('exit', (code, signal) => {
      mainIsFinished = true;
      if (signal) {
        console.log(`<exited by ${signal}>`);
      } else if (code) {
        console.log(`<exited with ${signal}>`);
      }
      process.exit(code ?? 1);
    });
    process.on('exit', () => {
      if (!mainIsFinished) {
        main.kill('SIGTERM');
      }
    });
  });
}
